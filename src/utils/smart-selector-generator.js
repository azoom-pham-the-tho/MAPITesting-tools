/**
 * Smart Selector Generator
 *
 * T·∫°o selectors b·ªÅn v·ªØng v·ªõi 7+ strategies v√† AI-based fallback
 * Thu·∫≠t to√°n: Multi-Strategy Scoring + Playwright Locator Integration
 *
 * M·ª•c ti√™u:
 * - 99%+ selector success rate
 * - Resilient to DOM changes
 * - Fast element finding (< 100ms)
 * - Playwright-compatible locators
 */

class SmartSelectorGenerator {
    constructor() {
        this.config = {
            // Strategy weights
            weights: {
                dataTestId: 100,
                ariaLabel: 95,
                id: 90,
                role: 85,
                uniqueClass: 80,
                text: 75,
                placeholder: 70,
                name: 65,
                xpath: 50,
                cssPath: 45,
                coordinates: 30
            },

            // Thresholds
            minScore: 40,
            preferredScore: 70,

            // Options
            maxFallbacks: 5,
            includeVisualInfo: true
        };

        this.selectorCache = new Map();
    }

    /**
     * Generate comprehensive selector strategies
     */
    generate(element, context = {}) {
        if (!element || !element.tagName) {
            throw new Error('Invalid element');
        }

        const tagName = element.tagName.toLowerCase();
        const strategies = [];

        // Strategy 1: data-testid (Highest priority)
        const dataTestId = element.getAttribute('data-testid') ||
                          element.getAttribute('data-test-id') ||
                          element.getAttribute('data-cy') ||
                          element.getAttribute('data-test');

        if (dataTestId) {
            strategies.push({
                type: 'dataTestId',
                selector: `[data-testid="${dataTestId}"]`,
                playwrightLocator: `page.getByTestId('${dataTestId}')`,
                score: this.config.weights.dataTestId,
                stability: 'high',
                uniqueness: this.checkUniqueness(`[data-testid="${dataTestId}"]`)
            });
        }

        // Strategy 2: ARIA Label + Role
        const role = element.getAttribute('role') || this.getImplicitRole(element);
        const ariaLabel = element.getAttribute('aria-label');
        const ariaLabelledBy = element.getAttribute('aria-labelledby');

        if (role && ariaLabel) {
            strategies.push({
                type: 'ariaLabel',
                selector: `[role="${role}"][aria-label="${ariaLabel}"]`,
                playwrightLocator: `page.getByRole('${role}', { name: '${ariaLabel}' })`,
                score: this.config.weights.ariaLabel,
                stability: 'high',
                uniqueness: this.checkUniqueness(`[role="${role}"][aria-label="${ariaLabel}"]`)
            });
        }

        // Strategy 3: ID (stable n·∫øu kh√¥ng auto-generated)
        if (element.id && !this.isAutoGeneratedId(element.id)) {
            const selector = `#${element.id}`;
            strategies.push({
                type: 'id',
                selector,
                playwrightLocator: `page.locator('${selector}')`,
                score: this.config.weights.id,
                stability: 'high',
                uniqueness: this.checkUniqueness(selector)
            });
        }

        // Strategy 4: Role + Name (Playwright preferred)
        const textContent = this.getElementText(element);
        if (role && textContent) {
            strategies.push({
                type: 'roleWithName',
                selector: `[role="${role}"]`,  // CSS selector equivalent
                playwrightLocator: `page.getByRole('${role}', { name: /${this.escapeRegex(textContent)}/ })`,
                text: textContent,
                score: this.config.weights.role,
                stability: 'medium',
                uniqueness: this.checkTextUniqueness(role, textContent)
            });
        }

        // Strategy 5: Unique stable classes
        const stableClasses = this.getStableClasses(element);
        if (stableClasses.length > 0) {
            const classSelector = `${tagName}.${stableClasses.join('.')}`;
            const uniqueness = this.checkUniqueness(classSelector);

            if (uniqueness === 'unique' || uniqueness === 'stable') {
                strategies.push({
                    type: 'uniqueClass',
                    selector: classSelector,
                    playwrightLocator: `page.locator('${classSelector}')`,
                    score: this.config.weights.uniqueClass,
                    stability: 'medium',
                    uniqueness
                });
            }
        }

        // Strategy 6: Text content (for clickable elements)
        if (['button', 'a', 'span', 'div'].includes(tagName) && textContent) {
            strategies.push({
                type: 'text',
                selector: `//*[text()="${textContent}"]`,  // XPath
                playwrightLocator: `page.getByText('${textContent}', { exact: true })`,
                text: textContent,
                score: this.config.weights.text,
                stability: 'medium',
                uniqueness: this.checkTextUniqueness('*', textContent)
            });
        }

        // Strategy 7: Placeholder (for inputs)
        const placeholder = element.getAttribute('placeholder');
        if (placeholder) {
            strategies.push({
                type: 'placeholder',
                selector: `[placeholder="${placeholder}"]`,
                playwrightLocator: `page.getByPlaceholder('${placeholder}')`,
                score: this.config.weights.placeholder,
                stability: 'medium',
                uniqueness: this.checkUniqueness(`[placeholder="${placeholder}"]`)
            });
        }

        // Strategy 8: Name attribute (for form inputs)
        const name = element.getAttribute('name');
        if (name) {
            strategies.push({
                type: 'name',
                selector: `[name="${name}"]`,
                playwrightLocator: `page.locator('[name="${name}"]')`,
                score: this.config.weights.name,
                stability: 'medium',
                uniqueness: this.checkUniqueness(`[name="${name}"]`)
            });
        }

        // Strategy 9: CSS Path (nth-child based)
        const cssPath = this.generateCSSPath(element);
        strategies.push({
            type: 'cssPath',
            selector: cssPath,
            playwrightLocator: `page.locator('${cssPath}')`,
            score: this.config.weights.cssPath,
            stability: 'low',
            uniqueness: 'unique'
        });

        // Strategy 10: XPath
        const xpath = this.generateXPath(element);
        strategies.push({
            type: 'xpath',
            selector: xpath,
            playwrightLocator: `page.locator('${xpath}')`,
            score: this.config.weights.xpath,
            stability: 'low',
            uniqueness: 'unique'
        });

        // Strategy 11: Coordinates (last resort)
        if (this.config.includeVisualInfo) {
            const rect = element.getBoundingClientRect();
            if (rect.x > 0 && rect.y > 0) {
                strategies.push({
                    type: 'coordinates',
                    coordinates: {
                        x: Math.round(rect.x),
                        y: Math.round(rect.y),
                        width: Math.round(rect.width),
                        height: Math.round(rect.height),
                        centerX: Math.round(rect.x + rect.width / 2),
                        centerY: Math.round(rect.y + rect.height / 2)
                    },
                    score: this.config.weights.coordinates,
                    stability: 'very-low'
                });
            }
        }

        // Sort by score
        strategies.sort((a, b) => b.score - a.score);

        // Filter by min score
        const validStrategies = strategies.filter(s => s.score >= this.config.minScore);

        // Return best + fallbacks
        return {
            element: {
                tag: tagName,
                text: textContent,
                role,
                id: element.id,
                classes: Array.from(element.classList)
            },
            primary: validStrategies[0],
            fallbacks: validStrategies.slice(1, this.config.maxFallbacks + 1),
            all: validStrategies,
            metadata: {
                generated: Date.now(),
                context
            }
        };
    }

    /**
     * Get stable classes (filter out dynamic/framework classes)
     */
    getStableClasses(element) {
        const blacklistPatterns = [
            /^v-/,              // Vue scoped classes
            /^data-v-/,         // Vue data attributes
            /^ant-/,            // Ant Design
            /^el-/,             // Element UI
            /^mui-/,            // Material UI
            /^MuiButton-/,      // Material UI components
            /^css-/,            // CSS-in-JS
            /^jss/,             // JSS
            /^makeStyles-/,     // Material UI makeStyles
            /^sc-/,             // Styled Components
            /^emotion-/,        // Emotion
            /^\d+$/,            // Pure numbers
            /^active$/,         // State classes
            /^focus$/,
            /^hover$/,
            /^disabled$/,
            /^selected$/
        ];

        return Array.from(element.classList).filter(cls => {
            return !blacklistPatterns.some(pattern => pattern.test(cls));
        });
    }

    /**
     * Check if ID is auto-generated
     */
    isAutoGeneratedId(id) {
        const autoGenPatterns = [
            /^v-/,
            /^data-v-/,
            /^mui-/,
            /^\d+$/,
            /^[a-f0-9]{8,}$/,   // Hex IDs
            /^id-\d+$/
        ];

        return autoGenPatterns.some(pattern => pattern.test(id));
    }

    /**
     * Get implicit ARIA role
     */
    getImplicitRole(element) {
        const tagName = element.tagName.toLowerCase();

        const roleMap = {
            'button': 'button',
            'a': 'link',
            'input': element.type === 'checkbox' ? 'checkbox' :
                     element.type === 'radio' ? 'radio' : 'textbox',
            'textarea': 'textbox',
            'select': 'combobox',
            'img': 'img',
            'nav': 'navigation',
            'main': 'main',
            'header': 'banner',
            'footer': 'contentinfo',
            'aside': 'complementary',
            'section': 'region',
            'article': 'article',
            'form': 'form',
            'table': 'table'
        };

        return roleMap[tagName] || null;
    }

    /**
     * Get clean element text
     */
    getElementText(element) {
        // Get direct text (not from children)
        let text = '';

        for (const node of element.childNodes) {
            if (node.nodeType === Node.TEXT_NODE) {
                text += node.textContent;
            }
        }

        // Fallback to full text if no direct text
        if (!text.trim()) {
            text = element.textContent || element.innerText || '';
        }

        return text.trim().replace(/\s+/g, ' ').substring(0, 100);
    }

    /**
     * Generate CSS path with nth-child
     */
    generateCSSPath(element, maxDepth = 5) {
        const path = [];
        let current = element;
        let depth = 0;

        while (current && current !== document.body && depth < maxDepth) {
            let selector = current.tagName.toLowerCase();

            // Add nth-child if has siblings of same type
            const siblings = Array.from(current.parentElement?.children || [])
                .filter(e => e.tagName === current.tagName);

            if (siblings.length > 1) {
                const index = siblings.indexOf(current) + 1;
                selector += `:nth-child(${index})`;
            }

            // Add ID if available and stable
            if (current.id && !this.isAutoGeneratedId(current.id)) {
                selector += `#${current.id}`;
                path.unshift(selector);
                break;  // ID is unique, stop here
            }

            path.unshift(selector);
            current = current.parentElement;
            depth++;
        }

        return path.join(' > ');
    }

    /**
     * Generate XPath
     */
    generateXPath(element) {
        if (element.id && !this.isAutoGeneratedId(element.id)) {
            return `//*[@id="${element.id}"]`;
        }

        const path = [];
        let current = element;

        while (current && current !== document.body) {
            let index = 1;
            let sibling = current.previousSibling;

            while (sibling) {
                if (sibling.nodeType === Node.ELEMENT_NODE &&
                    sibling.tagName === current.tagName) {
                    index++;
                }
                sibling = sibling.previousSibling;
            }

            const tagName = current.tagName.toLowerCase();
            path.unshift(`${tagName}[${index}]`);
            current = current.parentElement;
        }

        return '/' + path.join('/');
    }

    /**
     * Check selector uniqueness
     */
    checkUniqueness(selector) {
        try {
            const matches = document.querySelectorAll(selector);

            if (matches.length === 0) {
                return 'invalid';
            } else if (matches.length === 1) {
                return 'unique';
            } else if (matches.length <= 3) {
                return 'stable';
            } else {
                return 'multiple';
            }
        } catch (e) {
            return 'invalid';
        }
    }

    /**
     * Check text uniqueness
     */
    checkTextUniqueness(role, text) {
        try {
            const elements = role === '*' ?
                document.querySelectorAll('*') :
                document.querySelectorAll(`[role="${role}"]`);

            const matches = Array.from(elements).filter(el =>
                el.textContent.trim() === text
            );

            if (matches.length === 0) {
                return 'invalid';
            } else if (matches.length === 1) {
                return 'unique';
            } else if (matches.length <= 3) {
                return 'stable';
            } else {
                return 'multiple';
            }
        } catch (e) {
            return 'invalid';
        }
    }

    /**
     * Escape regex special characters
     */
    escapeRegex(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Find element using selector strategies (for replay)
     */
    async findElement(page, selectorData, options = {}) {
        const {
            timeout = 5000,
            waitForVisible = true,
            strict = false
        } = options;

        // Try primary selector first
        const primary = selectorData.primary;

        try {
            const element = await this.tryFindElement(
                page,
                primary,
                { timeout, waitForVisible, strict }
            );

            if (element) {
                console.log(`[SmartSelector] ‚úÖ Found with ${primary.type}`);
                return element;
            }
        } catch (e) {
            console.log(`[SmartSelector] ‚ùå Primary failed: ${e.message}`);
        }

        // Try fallbacks
        for (const fallback of selectorData.fallbacks || []) {
            try {
                const element = await this.tryFindElement(
                    page,
                    fallback,
                    { timeout: timeout / 2, waitForVisible, strict }
                );

                if (element) {
                    console.log(`[SmartSelector] üîß Found with fallback: ${fallback.type}`);
                    return element;
                }
            } catch (e) {
                // Continue to next fallback
            }
        }

        // Last resort: coordinates (if available)
        if (selectorData.primary?.coordinates) {
            const coords = selectorData.primary.coordinates;
            console.log(`[SmartSelector] üéØ Trying coordinates: (${coords.centerX}, ${coords.centerY})`);

            try {
                const element = await page.evaluateHandle((coords) => {
                    const el = document.elementFromPoint(coords.centerX, coords.centerY);
                    return el && el.offsetParent ? el : null;  // Check if visible
                }, coords);

                if (element) {
                    return element;
                }
            } catch (e) {
                console.log(`[SmartSelector] Coordinates failed: ${e.message}`);
            }
        }

        throw new Error(`Element not found after trying ${selectorData.fallbacks.length + 1} strategies`);
    }

    /**
     * Try find element v·ªõi m·ªôt strategy
     */
    async tryFindElement(page, strategy, options) {
        const { timeout, waitForVisible, strict } = options;

        // Convert to Playwright locator
        let locator;

        if (strategy.playwrightLocator) {
            // Use Playwright's smart locator
            locator = eval(strategy.playwrightLocator);
        } else if (strategy.selector) {
            // Fallback to CSS selector
            locator = page.locator(strategy.selector);
        } else {
            throw new Error('No selector available');
        }

        // Wait for element
        await locator.waitFor({
            state: waitForVisible ? 'visible' : 'attached',
            timeout,
            strict
        });

        return locator;
    }

    /**
     * Validate selector (check if still works)
     */
    async validateSelector(page, selectorData) {
        try {
            const element = await this.findElement(page, selectorData, {
                timeout: 2000,
                waitForVisible: false
            });

            return {
                valid: true,
                element,
                strategy: selectorData.primary.type
            };
        } catch (e) {
            return {
                valid: false,
                error: e.message
            };
        }
    }
}

// Export for browser
if (typeof window !== 'undefined') {
    window.SmartSelectorGenerator = SmartSelectorGenerator;
}

// Export for Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SmartSelectorGenerator;
}
